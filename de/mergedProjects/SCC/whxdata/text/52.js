rh._.exports({"0":[["SQL-Funktionen mit Tabellen"]],"1":[["\n"],["\n"],["\n","\n","Deklaration: bool Delete(string filter)","\n","Löschen eines Datensatzes aus der Tabelle mit der Bedingung \n ","filter","\n","Beispiel",":","\n","bool     ok","\n","ok := Database.Server.Table1.Delete('where id=1')","\n"," ","\n"],["\n","\n","Deklaration: bool first","\n","Geht zum ersten Datensatz der Ergebnismenge der zuvor \n mit \"select\" ausgeführten Abfrage (nur Cursortypen 1,2 und 3).","\n","Beispiel",":","\n","bool     ok","\n","ok := Database.Legato.P_OUT_VALUES.Select('where \n PROJECT_ID = 1', 2)","\n","ok := Database.Legato.P_OUT_VALUES.First","\n","if ok then","\n","  debug('Data found for project_id = \n 1')","\n","else","\n","  debug('No data found for project_id \n = 1')","\n","endif","\n"," ","\n"],["\n","\n","Deklaration: bool Insert(string filter)","\n","Einfügen eines Datensatzes in die Tabelle. Die Angabe \n eines Filters ","filter"," ist bei \"Insert\" nicht sinnvoll, \n es muss aber mindestens ein Leerstring angegeben werden.","\n","Beispiel",":","\n","bool err","\n","Database.Legato.MyUserTable.Userdata := 'My new \n value'","\n","err := Database.Legato.MyUserTable.Insert('')","\n"," ","\n"],["\n","\n","Deklaration: bool last","\n","Geht zum letzen Datensatz der Ergebnismenge der zuvor \n mit \"select\" ausgeführten Abfrage (nur Cursortypen 1,2 und 3).","\n","Beispiel",":","\n","bool     ok","\n","ok := Database.Legato.P_OUT_VALUES.Select('where \n PROJECT_ID = 1', 2)","\n","ok := Database.Legato.P_OUT_VALUES.Last","\n"," ","\n"],["\n","\n","Deklaration: bool next","\n","Geht zum nächsten Satz der Ergebnismenge der zuvor \n mit \"select\" ausgeführten Abfrage (alle Cursortypen).","\n","Beispiel",":","\n","bool     ok","\n","ok := Database.Legato.P_OUT_VALUES.Select('where \n PROJECT_ID = 1', 2)","\n","while ok do","\n","  ok := Database.Legato.P_OUT_VALUES.Next","\n","  debug(Database.Legato.P_OUT_VALUES.TIME_STARTED)","\n","enddo","\n"," ","\n"],["\n","\n","Deklaration: long NRows","\n","Liefert die Anzahl der Datensätze der Ergebnismenge \n der zuvor mit \"select\" ausgeführten Abfrage (nur Cursortypen \n 1,2 und 3).","\n","Beispiel",":","\n","bool     ok","\n","long     rows","\n","ok   := Database.Legato.P_OUT_VALUES.Select('', \n 2)","\n","rows := Database.Legato.P_OUT_VALUES.nRows","\n","debug('Rows in P_OUT_VALUES: ' + LToStr(rows, 10))","\n"," ","\n"],["\n","\n","Deklaration: bool prev","\n","Geht zum vorherigen Satz der Ergebnismenge der zuvor \n mit \"select\" ausgeführten Abfrage (nur Cursortypen 1,2 und 3).","\n","Beispiel",":","\n","bool     ok","\n","ok := Database.Legato.P_OUT_VALUES.Select('where \n PROJECT_ID = 1 ' +","\n","                                          'order \n by TIME_STARTED',","\n","                                          2)","\n","ok := Database.Legato.P_OUT_VALUES.Last","\n","while ok do","\n","  debug(Database.Legato.P_OUT_VALUES.TIME_STARTED)","\n","  ok := Database.Legato.P_OUT_VALUES.Prev","\n","enddo","\n"," ","\n"],["\n","\n","Deklaration: bool Select(string filter, long typ)","\n","Ausführen einer SQL-Abfrage mit der Bedingung ","filter. \n typ"," gibt den Cursortyp an:","\n","\n\t","\n\t\t","Typ","\n\t\t","ODBC \n\t\t Attribut","\n\t\t","Bedeutung","\n\t","\n\t","\n\t\t","0","\n\t\t","SQL_CURSOR_FORWARD_ONLY","\n\t\t","Tabelle \n\t\t kann nur vorwärts gescrollt werden; keine Abfrage mit NRows möglich, \n\t\t schnelle Bearbeitung von großen Tabellen.","\n\t","\n\t","\n\t\t","1","\n\t\t","SQL_CURSOR_KEYSET_DRIVEN","\n\t\t","Tabelle \n\t\t kann vor- und rückwärts gescrollt werden; Abfrage mit Nrows möglich; \n\t\t Datenänderungen durch andere Tasks werden teilweise erkannt (nur \n\t\t Wertänderung, nicht Insert-Funktionen!).","\n\t","\n\t","\n\t\t","2","\n\t\t","SQL_CURSOR_DYNAMIC","\n\t\t","Tabelle \n\t\t kann vor- und rückwärts gescrollt werden; Abfrage mit NRows möglich; \n\t\t Datenänderungen durch andere Tasks werden erkannt","\n\t","\n\t","\n\t\t","3","\n\t\t","SQL_CURSOR_STATIC","\n\t\t","Tabelle \n\t\t kann vor- und rückwärts gescrollt werden; Abfrage mit NRows möglich; \n\t\t Datenänderungen durch andere Tasks werden nicht erkannt!","\n\t","\n","\n"," ","\n","Je nach Datenbank werden unterschiedliche Cursortypen \n unterstützt.","\n",":","\n","Beim Win64-Cloud Connector darf in der abgefragten \n Tabelle kein Feld vom Typ \"BLOB\" oder \"CLOB\" vorhanden \n sein. Der Inhalt solcher Felder kann auch im Cloud Connector nicht behandelt \n werden. Die Ausführung des Selects führt zu einer schweren Ausnahme des \n Cloud Connector-Prozesses.","\n","Müssen Tabellen dieser Art abgefragt werden, \n bestehen z.B. folgende Möglichkeiten:","\n","Verwendung von \"Execute\" bzw. \"ExecuteEx\" \n oder","\n","Erstellen eines Views auf die Tabelle in der \n Datenbank und Abfrage der Daten mit \"Select\" auf den View. (Die \n Felder eines Views können wie bei einer Tabelle in das Cloud Connector \n importiert werden).","\n","Beispiel",":","\n","Database.Server.Table1.Select('where id=1', 2)","\n"," ","\n"],["\n","\n","Deklaration: bool Update(string filter)","\n","Schreiben von Daten in die Tabelle mit der Bedingung \n ","filter","\n","Die Datenbanktreiber liefern Fehlermeldungen wenn","\n","Felder vom Typ Identität (ID) importiert wurden, \n und über den Update-Befehl dieses Feld beschrieben werden soll","\n","ein zuvor ausgeführter SELECT-Befehl ohne weitere \n Datenbehandlung die Verbindung zur Datenbank blockiert","\n","das Datenformat der UPDATE-Variablen inkompatibel \n zum Datenbankfeld ist (z.B. Stringlänge überschritten)","\n","Beispiel",":","\n","bool err","\n","Database.Legato.MyUserTable.Userdata := 'My new \n value'","\n","err := Database.Legato.MyUserTable.Update('where \n id = 2')","\n"," ","\n\n\n"]],"2":[["SQL-Funktionen mit Tabellen"]],"4":[["Delete"],["First"],["Insert"],["Last"],["Next"],["NRows"],["Prev"],["Select"],["Update"]],"id":"52"})