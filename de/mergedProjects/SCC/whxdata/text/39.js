rh._.exports({"0":[["Blockoperationen"]],"1":[["\n"],["\n"],["\n","\n","Deklaration: long blocksize(block b)","\n","Liefert die Länge des Blockes b.","\n","Beispiel",":","\n","block    b","\n","long     size","\n","b := newblock(1024)","\n","size := blocksize(b)","\n","debug(LToStr(size,10))","\n"," ","\n"],["\n","\n","Deklaration: string BlockToStr(block b, pointer \n adr,","\n                        long \n size)","\n","Liest ","size"," \n Bytes aus dem Block ","b"," ab der Stelle \n ","adr ","und schreibt diese in einen \n String. Die Zählung beginnt mit 0. Nicht darstellbare Zeichen werden dabei \n durch '.' ersetzt.","\n","Beispiel",":","\n","block    b","\n","string   s","\n","b := OPC.GOPS.PLC1.Datenblock","\n","s := BlockToStr(b, 0, 20)","\n","debug(s)","\n"," ","\n"],["\n","\n","Deklaration: string BlockToStrAscii(block b, pointer \n adr,","\n                        long \n size)","\n","Liest ","size"," \n Bytes aus dem Block ","b"," ab der Stelle \n ","adr ","und schreibt diese in einen \n String. Die Zählung beginnt mit 0. Steuerzeichen werden dabei durch ihr \n Kürzel in spitzen Klammern ersetzt (z.B. 0x02 wird <STX>).","\n","Beispiel",":","\n","block    b","\n","string   s","\n","b := OPC.GOPS.PLC1.Datenblock","\n","s := BlockToStrAscii(b, 0, 20)","\n","debug(s)","\n"," ","\n"],["\n","\n","Deklaration: string BlockToStrHex(block b, pointer \n adr,","\n                        long \n size)","\n","Liest ","size"," \n Bytes aus dem Block ","b"," ab der Stelle \n ","adr ","und schreibt diese in einen \n String. Die Zählung beginnt mit 0. Die Zeichen werden dabei in hexadezimaler \n Form dargestellt und durch Leerzeichen getrennt (z.B. '00 01 02 0A').","\n","Beispiel",":","\n","block    b","\n","string   s","\n","b := OPC.GOPS.PLC1.Datenblock","\n","s := BlockToStrHex(b, 0, 20)","\n","debug(s)","\n"," ","\n"],["\n","\n","Deklaration: BlockToVar(block b, pointer adr,","\n                        long \n size)","\n","Kopiert den Block ","b"," ab der Position 0 in den \n Variablenbereich des Scripts. ","adr"," gibt die Adresse der Variablen \n an, ab der die Daten geschrieben werden. ","size"," bezeichnet dabei \n die Anzahl der Bytes, die geschrieben werden sollen.","\n","Beispiel",":","\n","block    b","\n","byte     data[128]","\n","b := OPC.GOPS.PLC1.Alarmblock","\n","BlockToVar(b, &data, 128)","\n"," ","\n",":","\n","Alle nach \"var\" liegenden Variablen, \n die im Bereich von \"size\" Bytes liegen, werden überschrieben! \n Dort dürfen keine Variablen vom Typ String oder Block definiert werden!","\n"],["\n","\n","Deklaration: CopyBlock(","block \n from, long frompos, block to, long topos, long size",")","\n","Kopiert Daten aus einem Block ","from"," \n ab der Position ","frompos"," in einen \n anderen Block ","to"," ab der Position \n ","topos",". ","size"," \n bezeichnet dabei die Anzahl der Bytes, die kopiert werden sollen. Die \n Zählung für die Positionen beginnt bei 0.","\n","Beispiel",":","\n","block from","\n","block to","\n","from := newblock(16)","\n","to := newblock(16)","\n","setblockstr(from, 0, 16, 'ABCDEFGHIJKLMNOP')","\n","copyblock(from, 0, to, 0, 4)","\n"," ","\n"],["\n","\n","Deklaration: FillBlock(block b, long pos,","\n                       long \n size, long fill)","\n","Das Zeichen ","fill"," wird ","size"," mal in den \n Block ","b"," geschrieben. Der Schreibvorgang wird an der Position ","pos"," \n begonnen.","\n","Beispiel",":","\n","block    b","\n","b := newblock(128)","\n","FillBlock(b, 0, 128, 0xFF)","\n"," ","\n"],["\n","\n","Deklaration: long GetBlockNum(block b, long pos,","\n                              long \n size, bool sign)","\n","Liest eine Integerzahl aus dem Block ","b"," ab der \n Position ","pos",", wobei die Zählung bei 0 beginnt. ","size"," bezeichnet \n dabei die Anzahl der Bytes, die ausgelesen werden sollen und ","sign",", \n ob die Zahl vorzeichenbehaftet ist. Gültige Formate sind:","\n"," ","\n","\n\t","\n\t\t","Size","\n\t\t","Sign","\n\t\t","Typ","\n\t","\n\t","\n\t\t","1","\n\t\t","True","\n\t\t","Byte  -128 \n\t\t - +127","\n\t","\n\t","\n\t\t","1","\n\t\t","False","\n\t\t","Byte  0 \n\t\t – 255","\n\t","\n\t","\n\t\t","2","\n\t\t","True","\n\t\t","Integer  -32.768 \n\t\t - 32.767","\n\t","\n\t","\n\t\t","2","\n\t\t","False","\n\t\t","Word  0 \n\t\t - 65.535","\n\t","\n\t","\n\t\t","4","\n\t\t","True","\n\t\t","Long  -2.147.483.648 \n\t\t bis 2.147.483.647","\n\t","\n","\n","Beispiel",":","\n","block    b","\n","long     l","\n","string   s","\n","b := \"OPC.GOPS.PLC1.Datablock\"","\n","l := GetBlockNum(b, 0, 2, false)","\n","s := GetBlockStr(b, 2, l)","\n"," ","\n"],["\n","\n","Deklaration: string GetBlockStr(block b, long pos, \n long size)","\n","Liest einen String aus dem Block ","b"," ab der Position \n ","pos"," wobei die Zählung bei 0 beginnt. ","size"," bezeichnet dabei \n die Anzahl der Bytes, die ausgelesen werden sollen. Der String wird automatisch \n mit einem Nullzeichen abgeschlossen.","\n","Beispiel",":","\n","block    b","\n","long     l","\n","string   s","\n","b := \"OPC.GOPS.PLC1.Datablock\"","\n","l := GetBlockNum(b, 0, 2, false)","\n","s := GetBlockStr(b, 2, l)","\n"," ","\n"],["\n","\n","Deklaration: MemCopy(pointer from, pointer to, long \n size)","\n","Kopiert Daten aus einem Variablenbereich des Scripts \n (","from",") in einen anderen (","to","). ","size"," bezeichnet dabei \n die Anzahl der Bytes, die kopiert werden sollen.","\n","Beispiel",":","\n","char  c1[128], c2[128]","\n","memcopy(&c1, &c2, 128)","\n"," ","\n"],["\n","\n","Deklaration: MemSet(pointer adr, long i, long size)","\n","Beschreibt Daten in dem Variablenbereich des Scripts \n (","adr",") mit dem Wert ","i",". ","size"," bezeichnet dabei die Anzahl \n der Bytes, die beschrieben werden sollen.","\n","Beispiel",":","\n","char  c1[128]","\n","memset(&c1, 32, 128)","\n"," ","\n"],["\n","\n","Deklaration: block NewBlock(long size)","\n","Erstellt einen neuen Block mit ","size"," Bytes Länge. \n Kann der gewünschte Speicherplatz nicht zur Verfügung gestellt werden, \n wird ein Leerblock mit der Länge 0 erstellt. Die maximale Größe eines \n Blockes beträgt 65.496 Bytes.","\n","Beispiel",":","\n","block    b","\n","b := NewBlock(1024)","\n","if BlockSize(b) = 0 then","\n","  debug('No sufficient memory available')","\n","endif","\n"," ","\n"],["\n","\n","Deklaration: SetBlockNum(block b, long pos,","\n                         long \n size, bool sign,","\n                         long \n x)","\n","Schreibt die Integerzahl ","x"," in den Block ","b"," \n ab der Position ","pos",", wobei die Zählung bei 0 beginnt. ","size"," \n bezeichnet dabei die Anzahl der Bytes, die geschrieben werden sollen und \n ","sign",", ob die Zahl vorzeichenbehaftet ist. Gültige Formate sind:","\n"," ","\n","\n\t","\n\t\t","Size","\n\t\t","Sign","\n\t\t","Typ","\n\t","\n\t","\n\t\t","1","\n\t\t","true","\n\t\t","Byte  -128 \n\t\t - +127","\n\t","\n\t","\n\t\t","1","\n\t\t","false","\n\t\t","Byte \n\t\t 0 – 255","\n\t","\n\t","\n\t\t","2","\n\t\t","true","\n\t\t","Integer  -32.768 \n\t\t - 32.767","\n\t","\n\t","\n\t\t","2","\n\t\t","False","\n\t\t","Word  0 \n\t\t - 65.535","\n\t","\n\t","\n\t\t","4","\n\t\t","True","\n\t\t","Long  -2.147.483.648 \n\t\t bis 2.147.483.647","\n\t","\n","\n","Beispiel",":","\n","block    b","\n","b := newblock(128)","\n","setblocknum(b, 0, 1, false, 6)","\n","setblockstr(b, 1, 6, 'ABCDEF')","\n"," ","\n"],["\n","\n","Deklaration: SetBlockStr(block b, long pos,","\n                         long \n size, string x)","\n","Schreibt den String ","x"," in den Block ","b"," \n ab der Position ","pos",", wobei die Zählung bei 0 beginnt. ","size"," \n bezeichnet dabei die Anzahl der Bytes, die geschrieben werden sollen.","\n","Beispiel",":","\n","block    b","\n","b := newblock(128)","\n","setblocknum(b, 0, 1, false, 6)","\n","setblockstr(b, 1, 6, 'ABCDEF')","\n"," ","\n"],["\n","\n","Deklaration: StrToBlock(string x)","\n","Es wird versucht, den String ","x"," als Folge von \n Zahlen zu interpretieren und diese in einen neuen Block zu schreiben. \n Die Zahlen können dezimal oder hexadezimal angegeben werden und durch \n Leerzeichen, Tabstopps oder Zeilenumbrüche getrennt sein.","\n","Beispiel",":","\n","block    b","\n","b := StrToBlock('00 01 02 03 04 05 06 07 08 09')","\n"," ","\n"],["\n","\n","Deklaration: block VarToBlock(pointer addr, long \n size)","\n","Kopiert Daten aus dem Variablenbereich des Scripts \n in den Rückgabeblock ab der Position 0. ","addr"," gibt die Adresse der \n Variable an, ab der die Daten gelesen werden. ","size"," bezeichnet dabei \n die Anzahl der Bytes, die kopiert werden sollen.","\n","Beispiel",":","\n","block    b","\n","byte     data[128]","\n","OPC.GOPS.PLC1.Statusblock := VarToBlock(&data,128)","\n"," ","\n"],["\n","\n","Deklaration: DelBlockValue(string folder, string \n name)","\n","Löscht den durch ","folder"," und ","name"," angegebenen \n Blockwert aus dem Hauptspeicher.","\n","Wird für ","name"," Leerstring übergeben (''), werden \n alle Blockwerte aus dem Ordner ","folder"," im Hauptspeicher gelöscht.","\n","Werden für ","folder"," und ","name"," Leerstring \n übergeben (''), werden alle Blockwerte im Hauptspeicher gelöscht.","\n","Beispiel",":","\n","DelBlockValue('Werte', 'Datenblock_1')","\n"," ","\n"],["\n","\n","Deklaration: block LoadBlockValue(string folder, \n string name)","\n","Lädt den durch ","folder"," und ","name"," angegebenen \n Blockwert aus dem Hauptspeicher und gibt diesen als Returnwert zurück.","\n","Beispiel",":","\n","block b","\n","b := LoadBlockValue('Werte', 'Datenblock_1')","\n"," ","\n"],["\n","\n","Deklaration: StoreBlockValue(string folder, string \n name, block b)","\n","Speichert den Block ","b"," unter dem durch ","folder"," \n und ","name"," angegebenen Namen im Hauptspeicher.","\n","Beispiel",":","\n","block b","\n","b := newblock(10)","\n","SetBlockStr(b, 0, 10, 'TEST_01234')","\n","StoreBlockValue('Werte', 'Datenblock_1', b)","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n"," ","\n\n\n"]],"2":[["Blockoperationen"]],"4":[["Blocksize"],["BlockToStr"],["BlockToStrAscii"],["BlockToStrHex"],["BlockToVar"],["CopyBlock"],["FillBlock"],["GetBlockNum"],["GetBlockStr"],["MemCopy"],["MemSet"],["NewBlock"],["SetBlockNum"],["SetBlockStr"],["StrToBlock"],["VarToBlock"],["DelBlockValue"],["LoadBlockValue"],["StoreBlockValue"]],"id":"39"})