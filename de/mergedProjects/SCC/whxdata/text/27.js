rh._.exports({"0":[["SendRecv-Verbindungen"]],"1":[["\n"],["\n","Nicht alle Geräte oder Steuerungen können über OPC \n angesprochen werden. Um eine Kommunikation mit solchen Partnern aufzubauen, \n kann die \"SendRecv\"-Schnittstelle verwendet werden.","\n","Die Verwendung der SendRecv-Schnittstelle kann insbesondere \n bei großen Projekten sinnvoll sein, da damit ein Telegramm mit nur einem \n Script über alle SPSen verarbeitet werden kann. Somit wird auch die Wartbarkeit \n erhöht. Allerdings ist der initiale Aufwand bei der SPS-Programmierung \n recht hoch.","\n"],["\n","Es sind Treiber für folgende Standardprotokolle verfügbar:","\n","TCP/IP","\n","Serielle Kommunikation mit 3964R oder offenes \n Protokoll (feste Länge, festes Endezeichen oder Quittungsverzug)","\n"],["\n","Selektieren Sie das Grundelement \"SendRecv\" \n im Projektbaum und wählen Sie im Kontextmenü den Befehl \"Neuer Treiber\".","\n","\n","Eine Auswahlliste bietet die möglichen Treiber an.","\n"],["\n","Selektieren Sie das Treiberelement im Projektbaum und \n wählen Sie im Kontextmenü den Befehl \"Neue Verbindung\".","\n","\n","Der \"Zeitwert für Reconnect\" gibt an, nach \n wievielen Sekunden ein Reconnect versucht werden soll.","\n","Die Einstellung von \"Verzögerung Send\" in \n [ms] gibt die Zeit an, wie lange nach dem Anstoßen des Send gewartet wird, \n bis die Daten wirklich an die Karte übergeben werden. Diese Funktion ist \n dann nutzbar, wenn keine gesicherte Rückmeldung der Karte für \"Kanal \n frei\" existiert, um ein gegenseitiges Überschreiben von Telegrammen \n zu verhindern. Der einzustellende Wert ist von der Gesamtkonfiguration \n der Kommunikation abhängig und muss empirisch ermittelt werden.","\n","Ähnliches gilt für \"Verzögerung Recv\", nur \n dass hier die Zeit nach dem Anstoßen des Receive angegeben wird.","\n","Durch Klick auf \"Parameter\" können je nach \n Treibertyp weitere Parameter eingestellt werden, z.B. die IP-Adresse und \n der Port für einen TCP/IP-Treiber.","\n","Die Verbindungen müssen nicht manuell angelegt werden, \n sondern können über das Script \"OnPrjStart\" aus der Datenbank-Tabelle \n \"P_CONNECTIONS\" gelesen werden. Zur Laufzeit werden sie dann \n über die IP in einer Extended Property verbunden. Dadurch sind keine Änderungen \n am Cloud Connector nötig, wenn sich SPSen ändern oder neue hinzukommen.","\n","Für UNIX-Cloud Connectors ist ausschließlich dieses \n Vorgehen möglich.","\n"],["\n","Für jede Verbindung werden vom System automatisch drei \n Variablen angelegt:","\n","\n\t","\n\t\t","Name","\n\t\t","Format","\n\t\t","Beschreibung","\n\t","\n\t","\n\t\t","Connectstatus","\n\t\t","Ganzzahl","\n\t\t","Status \n\t\t der Verbindung. Ist der Status \"0\" ist die Verbindung \n\t\t i.O. Beim Status \"1\" ist die Verbindung nicht aktiv \n\t\t oder im Aufbau. Negative Werte treten bei Verbindungsfehlern auf.","\n\t","\n\t","\n\t\t","RecvData","\n\t\t","Block","\n\t\t","Enthält \n\t\t die empfangenen Daten. Jedes neu empfangene Telegramm bewirkt \n\t\t eine Wertänderung von RecvData.","\n\t","\n\t","\n\t\t","SendStatus","\n\t\t","Ganzzahl","\n\t\t","Status \n\t\t von Sendeaufträgen. Ist ein Sendeauftrag fertig, wird die Sende-ID \n\t\t des Auftrages im SendStatus gespiegelt. Trat ein Fehler beim Senden \n\t\t auf, wird zu der ID der Wert 0x80000000 addiert.","\n\t","\n","\n\n\n"]],"2":[["SendRecv-Verbindungen"]],"4":[["Verfügbare Treiber (Win64)"],["Anlegen \n des Treiberelements"],["Anlegen \n von Verbindungen"],["Verbindungsvariablen"]],"5":[["IP,TCP,SendRecv"]],"id":"27"})