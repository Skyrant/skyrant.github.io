rh._.exports({"0":[["Funktionen der Send/Recv-Schnittstelle"]],"1":[["\n"],["\n"],["\n","\n","Deklaration: SendBlk(string name, long id, block \n data, long size)","\n","Sendet einen Datenblock ","data"," mit der Länge ","size"," \n Bytes über die Verbindung ","name",". Die ","id"," wird in der Variable \n \"SendStatus\" der Verbindung wieder zurückgespiegelt, wenn der \n Sendevorgang beendet ist. Trat beim  Senden ein Fehler auf, \n wird zusätzlich ein Fehlerbit übergeben. Der Wert von \"SendStatus\" \n ist dann 0x80000000 + ","id",".","\n","Der Befehl kann auch direkt an den Verbindungsnamen \n im Script angehängt werden:","\n","Beispiel",":","\n","block    b","\n","b := newblock(128)","\n","SendRecv.DriverSerial.ConnectionScanner.SendBlk(1, \n b, 128)","\n","oder…","\n","SendBlk('SendRecv.DriverSerial.ConnectionScanner', \n 1, b, 128)","\n"," ","\n"],["\n","\n","Deklaration: SendStr(string name, long id, string \n data)","\n","Sendet einen String ","data"," über die Verbindung \n ","name",". Die Sendelänge ist mit der Länge des Strings identisch. Die \n ","id"," wird in der Variable \"SendStatus\" der Verbindung wieder \n zurückgespiegelt, wenn der Sendevorgang beendet ist. Trat beim  Senden \n ein Fehler auf wird zusätzlich ein Fehlerbit übergeben. Der Wert von \"SendStatus\" \n ist dann 0x80000000 + ","id",".","\n","Der Befehl kann auch direkt an den Verbindungsnamen \n im Script angehängt werden:","\n","Beispiel",":","\n","string   s","\n","s := 'Teststring '","\n","SendRecv.DriverSerial.ConnectionScanner.SendStr(1, \n s)","\n","oder …","\n","SendBlk('SendRecv.DriverSerial.ConnectionScanner', \n 1, s)","\n"," ","\n"],["\n","\n","Deklaration: SendVar(string name, long id, address \n data, long size)","\n","Sendet einen Variablenbereich mit der Adresse ","data"," \n über die Verbindung ","name",". Die Sendelänge wird mit ","size"," spezifiziert. \n Die ","id"," wird in der Variable \"SendStatus\" der Verbindung \n wieder zurückgespiegelt, wenn der Sendevorgang beendet ist. Trat beim \n Senden ein Fehler auf, wird zusätzlich ein Fehlerbit übergeben. Der Wert \n von \"SendStatus\" ist dann 0x80000000 + ","id",".","\n","Der Befehl kann auch direkt an den Verbindungsnamen \n im Script angehängt werden:","\n","Beispiel",":","\n","struct data","\n","begin","\n","  long l","\n","  char c[80]","\n","end","\n","data.l := 26","\n","SetVarStr('ABCDEFGHIJKLMNOPQRSTUVWXYZ', &data.c, \n 26)","\n","SendRecv.DriverSerial.ConnectionScanner.SendVar(1, \n &data, 30)","\n","oder …","\n","SendVar('SendRecv.DriverSerial.ConnectionScanner', \n 1, &data, 30)","\n"," ","\n"],["\n","\n","Deklaration: SequenceBlk(string \n name, long id, block data, long size, long timeoutrecv, long timeoutterminate, \n long modeterminate)","\n","\n","Sendet einen \n Datenblock ","data"," mit der Länge ","size"," Bytes über die Verbindung \n ","name",". Die Verbindung wird aufgebaut, sofern sie noch nicht aktiv \n war. Nach dem Senden der Daten wird auf eine Antwort gewartet. Die Daten \n der Antwort werden über das Event ","OnValue"," \n übergeben.","\n","Die ","id"," \n wird im Event ","OnSend"," der \n Verbindung wieder zurückgespiegelt, wenn der Ablauf beendet ist.","\n","\nTrat beim Senden ein Fehler auf, oder wird innerhalb der Zeit ","timeoutrecv"," \n keine Antwort erhalten, wird zusätzlich ein Fehlerbit übergeben. Der Wert \n von ","OnSend"," ist dann 0x80000000 \n + ","id",".","\n","\nIst der Ablauf beendet, wird das Verhalten über ","modeterminate"," \n festgelegt:","\n","\n0","            "," die \n Verbindung bleibt aufgebaut, keine weitere Aktion.","\n1","            "," die \n Verbindung wird sofort abgebaut","\n2","            "," es \n wird die Zeit ","timeoutterminate"," \n abgewartet, ob ein weiterer Sendebefehl ansteht.","              ","\n"," ","\n","Beispiel:","\n","block    b","\n","b := newblock(128)","\n","SequenceBlk('SendRecv.DriverSerial.ConnectionScanner', \n 1, b, 128, 2000, 2000, 0)","\n"," ","\n"],["\n","\n"," ","\n","Deklaration: SequenceStr(string \n name, long id, string data, long timeoutrecv, long timeoutterminate, long \n modeterminate)","\n","\n","\n","Sendet einen \n String ","data"," über die Verbindung ","name",". Die Sendelänge ist \n mit der Länge des Strings identisch. Die Verbindung wird aufgebaut, sofern \n sie noch nicht aktiv war. Nach dem Senden der Daten wird auf eine Antwort \n gewartet. Die Daten der Antwort werden über das Event ","OnValue"," \n übergeben.","\n","Die ","id"," \n wird im Event ","OnSend"," der \n Verbindung wieder zurückgespiegelt, wenn der Ablauf beendet ist.","\n","\nTrat beim Senden ein Fehler auf, oder wird innerhalb der Zeit ","timeoutrecv"," \n keine Antwort erhalten, wird zusätzlich ein Fehlerbit übergeben. Der Wert \n von ","OnSend"," ist dann 0x80000000 \n + ","id",".","\n","\nIst der Ablauf beendet, wird das Verhalten über ","modeterminate"," \n festgelegt:","\n","\n0","            "," die Verbindung bleibt aufgebaut, \n keine weitere Aktion.","\n1","            "," die Verbindung wird sofort abgebaut","\n2","            "," es wird die Zeit ","timeoutterminate"," \n abgewartet, ob ein weiterer Sendebefehl ansteht.","        ","\n"," ","\n","Beispiel:","\n","string   s","\n","s := 'Teststring \n '","\n","SequenceStr('SendRecv.DriverSerial.ConnectionScanner', \n 1, s, 2000, 2000, 1)","\n"," ","      ","\n"],["\n","\n","Deklaration: SequenceVar(string \n name, long id, address data, long size, long timeoutrecv, long timeoutterminate, \n long modeterminate)","\n","\n","\n","Sendet einen \n Variablenbereich mit der Adresse ","data"," über die Verbindung ","name",". \n Die Sendelänge wird mit ","size"," spezifiziert. Die Verbindung wird \n aufgebaut, sofern sie noch nicht aktiv war. Nach dem Senden der Daten \n wird auf eine Antwort gewartet. Die Daten der Antwort werden über das \n Event ","OnValue"," übergeben.","\n","Die ","id"," \n wird im Event ","OnSend"," der \n Verbindung wieder zurückgespiegelt, wenn der Ablauf beendet ist.","\n","\nTrat beim Senden ein Fehler auf, oder wird innerhalb der Zeit ","timeoutrecv"," \n keine Antwort erhalten, wird zusätzlich ein Fehlerbit übergeben. Der Wert \n von ","OnSend"," ist dann 0x80000000 \n + ","id",".","\n","\nIst der Ablauf beendet, wird das Verhalten über ","modeterminate"," \n festgelegt:","\n","\n0","            "," die \n Verbindung bleibt aufgebaut, keine weitere Aktion.","\n1","            "," die \n Verbindung wird sofort abgebaut","\n2","            "," es \n wird die Zeit ","timeoutterminate"," \n abgewartet, ob ein weiterer Sendebefehl ansteht.","              ","\n"," ","\n","Beispiel:","\n","struct data","\n","begin","\n","long l","\n","char c[80]","\n","end","\n","data.l := 26","\n","SetVarStr('ABCDEFGHIJKLMNOPQRSTUVWXYZ', \n &data.c, 26)","\n","SequenceVar('SendRecv.DriverSerial.ConnectionScanner', \n 1, &data, 30, 2000, 2000, 2)","\n"," ","\n"],["\n","\n","Deklaration: long \n SequenceState(string name)","\n","\n","\n","Prüft den Sequenzstatus \n der Verbindung ","name",". Der \n Status kann folgen de Werte annehmen:","\n"," ","\n","-1","          "," die \n Verbindung ","name"," existiert \n nicht","\n","0","            "," Verbindung \n vorhanden und frei; keine Sequenz aktiv","\n","1","            "," es \n läuft eine Sequenz auf der Verbindung","\n"," ","\n","Beispiel:","\n","long state","\n","state := SequenceState('SendRecv.DriverSerial.ConnectionScanner')","\n\n\n"]],"2":[["Funktionen der Send/Recv-Schnittstelle"]],"4":[["SendBlk"],["SendStr"],["SendVar"],["SequenceBlk"],["SequenceStr \n "],["SequenceVar"],["SequenceState"]],"5":[["SendRecv"]],"id":"60"})