rh._.exports({"0":[["Formatkonvertierungen"]],"1":[["\n"],["\n","Werden in einem arithmetischen Ausdruck zwei Operanden \n unterschiedlichen Typs verwendet, wird der Long-Operand automatisch in \n einen Double-Wert konvertiert. Das Ergebnis der Operation ist ein Double-Wert. \n Soll die Berechnung einen Integerwert (Long) liefern, muss der Double-Operand \n oder das Ergebnis durch die Funktion \"Round\" in einen Long-Wert \n konvertiert werden.","\n"],["\n","\n","Deklaration: long DToF(double x)","\n","Wandelt den Double-Wert ","x"," in das Fließkommaformat \n der Simatic-S7.","\n","Das Ergebnis dieser Funktion kann im Script nicht weiter \n verarbeitet werden, sondern ist nur dazu geeignet, mit SetBlockNum in \n einen Datenblock eingetragen zu werden, der in ein AG des Typs Simatic \n S7 geschrieben werden soll.","\n","Beispiel",":","\n","block    b","\n","b := NewBlock(6)","\n","SetBlockNum(b, 0, 2, false,","\n","            Endian(Value.InputAsInteger, \n true, false)","\n","            )","\n","SetBlockNum(b, 2, 4, false,","\n","            DToF(Value.InputAsFloat)","\n","            )","\n","OPC.GOPS.PLC1.Targetblock := b","\n"," ","\n"],["\n","\n","Deklaration: long DToKG(double x)","\n","Wandelt den Double-Wert ","x"," in eine Fließkommazahl \n mit dem KG-Format der Simatic-S5.","\n","Beispiel",":","\n","double    d","\n","long      l","\n","d := sin(pi)","\n","l := DToKG(d)","\n","OPC.GOPS.PLC1.Distance := l","\n"," ","\n"],["\n","\n","Deklaration: string DToStr(double x)","\n","Wandelt den Double-Wert ","x"," in einen String. Die \n Zahl wird je nach Größe entweder exponential oder dezimal dargestellt.","\n","Beispiel",":","\n","double    d","\n","d := 125.56 / 37","\n","debug('Result : ' + DToStr(d))","\n"," ","\n"],["\n","\n","Deklaration: string DToStrEx(double x, long digits)","\n","Wandelt den Double-Wert ","x"," in einen String mit \n ","digits"," Stellen. Dabei werden Vorzeichen und Dezimalpunkt nicht \n als Stellen gewertet.","\n","Beispiel",":","\n","double    d","\n","d := 125.56 / 37","\n","debug('Result : ' + DToStrEx(d, 8))","\n"," ","\n"],["\n","\n","Deklaration: long Endian(long x, bool wo, bool by)","\n","Ist ","by"," = true werden jeweils High- und Low-Byte \n des Arguments ","x"," miteinander vertauscht. Ist ","wo"," = true wird \n das High- und Low-Word des Arguments ","x"," miteinander getauscht. Diese \n Funktion erleichtert die Bearbeitung von Daten, die von anderen Maschinen  stammen \n (z.B.Simatic-S5).","\n","Beispiel",":","\n","long x","\n","x := 1","\n","debug('TestEndian:')","\n","debug('0,0 --> ' + LToStr(endian(x, false, false), \n 2))","\n","debug('0,1 --> ' + LToStr(endian(x, false, true \n ), 2))","\n","debug('1,0 --> ' + LToStr(endian(x, true , false), \n 2))","\n","debug('1,1 --> ' + LToStr(endian(x, true , true \n ), 2))","\n","   ","\n","Ausgabe im Logbuch:","\n","TestEndian:","\n","0,0 --> 1","\n","0,1 --> 1 00000000","\n","1,0 --> 1 00000000 00000000","\n","1,1 --> 1 00000000 00000000 00000000","\n"," ","\n"],["\n","\n","Deklaration: double FToD(long x)","\n","Wandelt einen Wert aus dem Fließkommaformat der Simatic-S7 \n in einen Double-Wert.","\n","Als sinnvolle Eingabe dieser Funktion eignen sich nur \n Werte, die mittels GetBlockNum aus einem Datenblock extrahiert wurden, \n der aus einem AG des Typs Simatic S7 gelesen wurde.","\n","Beispiel",":","\n","double d","\n","d := FToD(GetBlockNum(OPC.GOPS.PLC1.Targetblock, \n 2, 4, false))","\n"," ","\n"],["\n","\n","Deklaration: double KGToD(long x)","\n","Wandelt eine Fließkommazahl ","x"," mit dem KG-Format \n der Simatic-S5 in einen Double-Wert.","\n","Beispiel",":","\n","long    l","\n","double  d","\n","l := OPC.GOPS.PLC1.ValueAsKG","\n","d := KGToD(l)","\n"," ","\n"],["\n","\n","Deklaration: string LToStr(long x, long radix)","\n","Konvertiert den Long-Wert ","x"," in einen String. \n Der Parameter ","radix"," legt die Basis fest, auf der die Konvertierung \n stattfinden soll - mögliche Werte liegen im Bereich von 2 bis 36.","\n","Wenn ","radix"," den Wert 10 hat und ","x"," kleiner \n als Null ist, stellt LToStr dem Ergebnis ein Minuszeichen voran.","\n","Beispiel",":","\n","long    l","\n","string  s","\n","l := 1247","\n","s := LToStr(l, 10)","\n","debug('Decimal     : ' \n + s)","\n","s := LToStr(l, 16)","\n","debug('Hexadecimal : ' + s)","\n","s := LToStr(l, 2)","\n","debug('Binary      : \n ' + s)","\n"," ","\n"],["\n","\n","Deklaration: string Printf(string format, ...)","\n","Der Befehl erzeugt einen String aus einem Formatstring \n ","format"," und einer beliebigen Anzahl Parameter. Die Parameter können \n Strings oder numerische Werte sein. Für den Formatstring gelten folgende \n Angaben:","\n"," ","\n","\n\t","\n\t\t","Formatzeichen","\n\t\t","Interpretation","\n\t","\n\t","\n\t\t","u","\n\t\t","Dezimal \n\t\t ohne Vorzeichen","\n\t","\n\t","\n\t\t","d","\n\t\t","Dezimal \n\t\t mit Vorzeichen","\n\t","\n\t","\n\t\t","x","\n\t\t","Hexadezimal \n\t\t Kleinschreibung","\n\t","\n\t","\n\t\t","X","\n\t\t","Hexadezimal \n\t\t Großschreibung","\n\t","\n\t","\n\t\t","s","\n\t\t","String","\n\t","\n","\n"," ","\n","Dem Formatzeichen muss ein '","%","' vorangestellt \n sein. Bei numerischen Formaten kann die Länge sowie führende Nullen parametriert \n werden.","\n","Beispiel",":","\n","string    s, partstr","\n","partstr := 'This is the part to add'","\n","s := printf('String                        : \n %s', partstr)","\n","debug(s)","\n","s := printf('Decimal without / with sign   : \n %u / %d', 123, -456)","\n","debug(s)","\n","s := printf('Hex 4 digits with leading zero: %04x', \n 123)","\n","debug(s)","\n"," ","\n"],["\n","\n","Deklaration: double StrToD(string source)","\n","Konvertiert den durch ","source"," bezeichneten String \n in eine Gleitkommazahl und liefert das Ergebnis als Double zurück.","\n","Beispiel",":","\n","double    d","\n","d := StrToD('-1.7567E+02')","\n","debug(DToStr(d))","\n"," ","\n"],["\n","\n","Deklaration: long StrToL(string source)","\n","Konvertiert den durch ","source"," bezeichneten String \n in einen Long-Wert.","\n","Beispiel",":","\n","long    l","\n","l := strtol('-1')","\n"," ","\n"],["\n","\n","Deklaration: long StrToLEx(string source,","\n                           long \n radix)","\n","Konvertiert eine in dem durch ","source"," bezeichneten \n String enthaltene Zahl in einen Long-Wert","\n","Der Parameter ","radix"," gibt die dabei für die im \n String gespeicherte Zahl angenommene Zahlenbasis an. Zulässig sind die \n Werte 0, sowie 2 bis 36. Wird als radix 0 angegeben, bestimmen die ersten \n Zeichen des Strings die zu verwendende Zahlenbasis:","\n","\n\t","\n\t\t","Anfangszeichen","\n\t\t","Zahlenbasis","\n\t","\n\t","\n\t\t","1...9","\n\t\t","Dezimaldarstellung","\n\t","\n\t","\n\t\t","0x","\n\t\t","Hexadezimaldarstellung","\n\t","\n\t","\n\t\t","0","\n\t\t","Oktaldarstellung","\n\t","\n","\n"," ","\n","Die Konvertierung endet beim ersten nicht wandelbaren \n Zeichen im String.","\n","Beispiel",":","\n","long    l, k","\n","l := StrToLEx('0x1D7F', 0)","\n","k := StrToLEx('0001110101111111', 2)","\n"," ","\n"],["\n","\n","Deklaration: string UToStr(dword x, long radix)","\n","Konvertiert den dWord-Wert ","x"," in einen String. \n Der Parameter ","radix"," legt die Basis fest, auf der die Konvertierung \n stattfinden soll - mögliche Werte liegen im Bereich von 2 bis 36.","\n","Beispiel",":","\n","dword    d","\n","string   s","\n","d := 1247","\n","s := UToStr(d, 10)","\n","debug('Decimal     : ' \n + s)","\n","s := UToStr (d, 16)","\n","debug('Hexadecimal : ' + s)","\n","s := UToStr (d, 2)","\n","debug('Binary      : \n ' + s)","\n"," ","\n\n\n"]],"2":[["Formatkonvertierungen"]],"4":[["DToF"],["DToKG"],["DToStr"],["DToStrEx"],["Endian"],["FToD"],["KGToD"],["LToStr"],["Printf"],["StrToD"],["StrToL"],["StrToLEx"],["UToStr"]],"id":"45"})