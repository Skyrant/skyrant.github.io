rh._.exports({"0":[["Progammierte Datenquellen"]],"1":[["\n"],["\n","Die \"select\"-Prozedur unterstützt auch das \n Erstellen von serverseitigen Datenquellen in Java oder JavaScript.","\n"],["\n","Datenquellen können als Java-Klassen implementiert \n werden. Diese Klassen müssen durch ","@JavaRepoResource(connectionName=\"name-of-schema\") \n ","kommentiert sein. Dieser Kommentar definiert das Schema (GP_R_CONNECTIONS), \n zu dem diese Datenquelle gehören soll. Eine Java-Klasse, die solcherart \n kommentiert ist, kann mehr als eine Datenquelle für dieses Schema implementieren.","\n","Für jede Datenquelle muss eine Klasse zwei Methoden \n implementieren. Beide müssen die übliche RPC-Methoden-Signatur (Objekt \n method(SapientCallContext, Objekt)) haben und müssen entsprechend kommentiert \n sein, damit sie vom Repository-Loader erkannt werden:","\n","@QueryFields(name=\"name-of-the-data-source\") \n ","Identifiziert die Methode, die vom \n Repository-Loader aufgerufen wurde um die Feldliste der Datenquelle zu \n holen. Diese Methode wird nur aufgerufen, während die Sapient Engine das \n Repository lädt oder neu lädt. In dieser Zeit ist das Repository (oder \n die neue Version davon, im  Falle eines Neuladens) nicht durch normale \n Sapient Engine Methoden erreichbar. Nichtsdestotrotz kann es sein, dass \n die Implementierung dieser Methode Informationen über das Schema benötigt, \n zu dem sie gehört. Um dies anzupassen, übergibt der Repository-Loader \n eine Referenz auf das Java Schema-Objekt als Parameter \"schema\" \n an diese Methode. Die \"fields\"-Methode sollte einen JSON-kompatiblen \n Array von JSON-Objekten zurückgeben, von denen jedes ein Feld der Datenquelle \n definiert. Für jedes Feld kann die folgende Information übergeben werden:","\n","name (String) \n - Der Name des Feldes / der Spalte.","\n","type (Integer) \n - Der JDBC-Typ des Feldes / der Spalte (eine der java.sql.Types-Konstanten).","\n","pki (Integer, \n optional) - Wenn das Feld Teil des Primärschlüssels der Ressource ist, \n seine Position in diesem Schlüssel (1, 2, ...). Wenn das Feld nicht Teil \n des Primärschlüssels ist, sollte pki bei der Feldinformation weggelassen \n oder mit 0 (Zahl Null) übergeben werden.","\n","ref (String, \n optional) - Wenn das Feld eine ausgehende Referenz (\"Foreign Key\") \n zu einer anderen Datenquelle ist, sollte dieser String das als String \n in der Form \"table.field\" spezifizieren.","\n","titles \n (Array von Strings oder String, optional) - Spaltentitel zur Anzeige im \n Client. Wenn ein einzelner String, wird dieser Wert für alle Benutzersprachen \n verwendet. Wenn ein Array, definiert jedes Element die Title fr eine der \n Sprachen, die im Schema \"repository\" enthalten sind (Hinweis: \n Nicht im Schema, zu dem diese Datenquelle gehört!)","\n","hints \n (Array von Strings oder String, optional) - Kurze Beschreibung des jeweiligen \n Feldes, ggf. in einem Tooltipp. Einstellungen der Sprachumgebung werden \n genauso verwendet wie für \"titles\".","\n","@","QueryMethod(name=\"name-of-the-data-source\") \n ","Verwalte die Methode, die aufgerufen \n werden soll, um die Daten abzurufen. Wird von der JSON-RPC-Methode \"select\" \n aufgerufen. Dabei werden die Inhalte ihrer \"query\"-Parameter \n an die \"query\"-Methode übergeben (\"resources\", \n \"fields\", \"relations\", \"filter\", \"sort\" \n etc.) Es wird keine Neubearbeitung dieser Parameter durchgeführt, ehe \n die query-Methode aufgerufen wird. Sie werden als JSON-kompatible Werte \n genauso übergeben, wie sie vom Client empfangen werden.","\n"],["\n","Die Skript-Dateien, die in JavaScript programmierte \n Datenquellen definieren, müssen im Unterverzeichnis <scripts|customscripts>/query/<schemaname>/ \n gespeichert sein.","\n\n\n"]],"2":[["Programmierte Datenquellen"]],"3":[["Java-Klassen"],["JavaScript"]],"5":[["Datenquelle"]],"id":"17"})