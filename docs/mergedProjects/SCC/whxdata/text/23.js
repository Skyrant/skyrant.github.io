rh._.exports({"0":[["OPC_UA"]],"1":[["\n"],["\n"],["\n","Unter dem Knoten OPC_UA können OPC_UA-Sitzungen angelegt \n werden. Diese werden im Menü sowie in den Dialogen als \"Server\" \n bezeichnet.","\n","\n","Der Grundknoten \"OPC_UA\" hat im Eigenschaftsdialog \n den Pfad zum Zertifikatsspeicher und einen Button zum Anlegen neuer Zertifikate.","\n","\n","Die Zertifikate werden im Dateisystem angelegt und \n nicht im Windows-Zertifikatspeicher (Kompatibilität zur Unix-Version).","\n","Nach dem Anlegen eines neuen Servers werden zunächst \n dessen Eigenschaften festgelegt.","\n","Die URL und die Security Parameter des Servers können \n manuell eingegeben werden (Offlineparametrierung) oder über die Discoveryfunktion \n gesucht und übernommen werden. ","\n","\n"," ","\n","Beim späteren Onlinebetrieb wird bei Änderung des Verbindungsstandards \n ein Event ausgelöst. Diesem kann ein Skriptaufruf zugeordnet werden. Der \n übergebene Wert (@Value) kann dabei folgende Zustände annehmen:","\n","\n\t","\n\t\t","Wert","\n\t\t","Status","\n\t","\n\t","\n\t\t","0","\n\t\t","Disconnected","\n\t","\n\t","\n\t\t","1","\n\t\t","Connected","\n\t","\n\t","\n\t\t","2","\n\t\t","Warning watchdog","\n\t","\n\t","\n\t\t","3","\n\t\t","Reconnect","\n\t","\n\t","\n\t\t","4","\n\t\t","Shutdown","\n\t","\n\t","\n\t\t","5","\n\t\t","New Session created","\n\t","\n","\n"," ","\n","Wird die Discoveryfunktion verwendet, muss eine Verbindung \n zu dem Discoveryserver vorhanden sein und der Pfad sowie der Zugangspunkt \n bekannt sein.","\n",":","\n","Als Discoverymethode ist derzeit nur \"Local \n Discovery Server\" zulässig!","\n","Die gefundenen Interfaces werden in der oberen Liste \n des Ergebnisdialogs angezeigt. Für den dort selektierten Server werden \n in der unteren Liste die vorhandenen Securitystufen angezeigt. In dieser \n zweiten List kann dann die gewünschte Kommunikationsart ausgewählt werden. \n Die Parameter werden mit Doppelklick bzw. durch Drücken des OK-Buttons \n übernommen. ","\n","\n"],["\n","Ist der Server angelegt, kann über das Kontextmenü \n eine Reihe von Funktionen gewählt werden:","\n","\n","Ist der Server erreichbar, kann z.B. ein Verbindungstest \n durchgeführt werden (Connect), die Namensräume angezeigt werden (Namensräume…) \n oder die Struktur des Servers angesehen werden (Durchsuchen…).","\n"],["\n","Die Struktur des Servers wird als Baum dargestellt. \n Dabei werden die unterschiedlichen Knotentypen durch eigene Icons visualisiert:","\n","\n","Im rechten Fenster werden Details zum aktuell selektierten \n Knoten dargestellt. Die Node-Id (wird für alle Funktionen eines Knotens \n benötigt) besteht aus drei Teilen, die durch einen Querstrich (|) getrennt \n sind. Der erste Teil gibt den Index des Namensraums an, der zweite den \n Typ der Node-Id und der dritte die Node-Id selbst.","\n",":","\n","Es werden im Cloud Connector derzeit nur zwei \n Typen der Node-Id unterstützt. Diese sind Number und String!","\n","Links im Baum selektierte Knoten können über Add zw. \n Enter übernommen werden, wenn \"Class\" eine Variable ist. In \n der Liste der ausgewählten Knoten können Variablen wieder gelöscht werden \n [Remove] oder auch die gesamte Liste gelöscht werden [Delete list].","\n","Über [Import] werden alle Items aus der Liste mit den \n angegebenen Importparametern importiert.","\n","Handelt es sich bei einem Item um eine Struktur, wird \n diese komplett mit Ordnern und Werten abgebildet.","\n"],["\n","Die Bezeichnungen der Namensraume können über die Funktion \n \"Namensräume…\" eingesehen werden.","\n","\n"],["\n","Unter dem Server können nun SPS-Werte angelegt werden. \n Die Parameter Node-Id, Node-Typ und Namensraum können manuell eingegeben \n werden oder aus der Struktur des Servers übernommen werden. Dabei können \n nur Knoten vom Typ \"Variable\" importiert werden. Der Datentyp \n der Variable kann gewählt bzw. bei importierten Elementen angezeigt werden. \n Beim Import der Knoteninformation werden diese Felder automatisch befüllt \n bzw. korrigiert.","\n","\n","Die Struktur kann auf zwei Arten behandelt werden. \n Welche davon verwendet werden soll, kann unter Struktur-Parametern eingestellt \n werden.","\n","Dynamisch: ","\n","Die Elemente der Struktur werden nicht im Projekt gespeichert \n und können nicht mit Ereignissen vom Typ OnValue versehen werden. Die \n Struktur selbst kann folgende Ereignisse bekommen:","\n","1. OnInsert: neuer Unterknoten wurde eingefügt.","\n","2. OnDelete: existierender Unterknoten wurde gelöscht.","\n","3. OnNodeValue: Wert des Unterknotens wurde geändert.","\n","4. OnValue: Wertänderungen bei einem oder mehreren \n Unterknoten.","\n","Statisch: ","\n","Die Elemente der Struktur werden im Projekt gespeichert \n und wie einzelne Variablen behandelt. Jeder Unterknoten vom Typ OPC-UA-Wert \n kann ein Ereignis vom Typ OnValue bekommen.","\n"," ","\n","Das Verhalten der Schreib-Funktion hängt von zwei Parametern \n ab:","\n","1. Alle Knoten beschreiben: Beschreiben der Hauptstruktur \n erzwingt das Beschreibung aller Unterknoten.","\n","2. Unterknoten direkt beschreiben: die Änderung eines \n Unterknotens (z.B. Wertzuordnung in einem Skript) führt sofort zu einer \n Schreib-Aktion für diesen einen Unterknoten.","\n","Ist keine dieser beiden Optionen selektiert, wartet \n das System auf einen Schreib-Befehl für das Hauptstrukturelement. Der \n Schreib-Befehl wird dann nur jeden geänderten Unterknoten beschreiben.","\n","Wird die Option \"Bei Projektstart anmelden\" \n gewählt, wird die Variable nach Start des Projekts mit dem parametrierten \n Abtastintervall angefordert.","\n"," ","\n","Im Kontextmenü des SPS Werts können verschiedene Testfunktionen \n durchgeführt werden:","\n","\n","Sollen mehrere Items dieselbe Funktionalität bekommen \n (z.B. gleichzeitiges Lesen/Schreiben, gleiches Abtastinverall), können \n diese in einer Gruppe zusammengefasst werden.","\n","\n"],["\n","Um die Funktionalität in Scripten nutzen zu können, \n wurde der Befehl \"ExtNodeFunc\" eingeführt. Die Beschreibung \n finden Sie unter ","Befehle - Steuern von \n Elementen",".","\n"],["\n"],["\n","Legt man z.B. mittels CreateNode mehrere \n OPC-Items direkt am OPC-UA-Server-Knoten an (Struktur im SCC: OPC_UA.<OPC-UA-Servername>.<OPC-Item[1..i]>), \n so wird je Item eine eigene Subscription am OPC-UA-Server erzeugt. \n Die Anzahl der Subscriptions ist in manchen Fällen begrenzt. \n Diese Begrenzung führt dazu, dass Items, die über dieser Grenze liegen, \n nicht mehr erzeugt und verbunden werden können.","\n","Diese Limitierung kann umgangen werden, indem man je \n OPC-UA-Server eine oder mehrere Gruppen als Zwischenebene einfügt (Struktur \n im SCC: OPC_UA.<OPC-UA-Servername>.<OPC-UA Gruppe [1..i]>.<OPC-Item[1..i]>). \n Die Subscription wird in diesem Fall der Gruppe übergeben (Attribut: \n autosubsc=\"true\"), welche diese an die der Gruppe zugeordneten \n Items weitervererbt. Die Anzahl Items je Gruppe ist unbegrenzt; hier ist \n allerdings je nach Anwendungsfall insbesondere die Performance bei der \n Datenübertragung zu testen. Es besteht die Option, mehrere Gruppen je \n Server anzulegen, wobei hier wiederum das Limit für Subscriptions zu \n beachten ist.","\n","Die Begrenzung der Anzahl Subscriptions ist \n immer bezogen auf je einen OPC-UA-Server, d.h., je eine SPS. \n ","\n"],["\n","Strukturen sind als Items vom Typ String im SCC in \n der OPC-UA-Verbindung anzulegen.","\n","Beispieldeklaration im SPS-Programm:","\n","Version_Nr Array[0..4] of Char Wert in SPS","\n","Version_Nr[0] Char 0","\n","Version_Nr[1] Char 2","\n","Version_Nr[2] Char .","\n","Version_Nr[3] Char 0","\n","Version_Nr[4] Char 1","\n"," ","\n","Auswertung im SCC:","\n","Es können die einzelnen 5 Bytes als je eigenes Items \n ausgewertet werden, aus Performancegründen empfiehlt es sich, das ganze \n Array mit den 5 Einzelbytes auszulesen. Das Aufbau im SCC ist wie folgt:","\n","OPC_UA.<OPC_SERVER>.<Gruppe>.Version_Nr","\n"," ","\n","Als Datentyp ist String anzugeben. Es wird nun im SCC \n für Strukturen standardmäßig folgende Datenstruktur vom Typ String zurückgeliefert:","\n","{val1,val2,..val[i]}","\n"," ","\n","Die einzelnen Werte val sind ASCII-Zeichen im Dezimalformat. \n Um diese in eine String zu wandeln, muss man den DEZ-Wert in HEX wandeln \n und diesen nach ASCII. Dies kann am besten mit den Block-Funktionen des \n SCC erfolgen.","\n","Beispielskript:","\n","string szVal, szTmp, x, y","\n","long i, nLen, nOff","\n","block b","\n"," ","\n","// if using structures in plc-programm, you get an \n object with this structure:","\n","// {val1, val2, ... val[i]}","\n","// The value val is a decimal-value, that is to convert \n to hexadecimal format","\n","// this hex-value is to convert to ascii","\n","// Example:","\n","// value from PLC via OPC-UA: {48,50,46,48,49}","\n","// value afer conversion to hex-values: 30 32 2E 30 \n 31","\n","// value after conversion to ascii: 0 2 . 0 1","\n","szVal := ''","\n","// eliminate {} in the string","\n","nLen := StrLen(_szValue)","\n","nOff := nLen-2","\n","szTmp := SubStr(_szValue, 1, nOff)","\n","nLen := StrLen(szTmp)","\n"," ","\n","// eliminate the comma-separators in the string","\n","i := 0","\n","x := ''","\n","while i<nLen do","\n","x := SubStr(szTmp, i, 1)","\n","if (x = ',') then szTmp := StrDel(szTmp, i, 1) endif","\n","i := i + 1","\n","enddo","\n"," ","\n","// read alway 2 characters and convert them to hex-values","\n","nLen := StrLen(szTmp)","\n","i := 0","\n","x := ''","\n","b := newblock(1)","\n","while i<nLen do","\n","x := SubStr(szTmp, i, 2)","\n","SetBlockNum(b, 0, 1, false, StrTolEx(x, 10))","\n","szVal := szVal + GetBlockStr(b, 0, 1)","\n","i := i + 2","\n","enddo ","\n","return szVal","\n"," ","\n"],["\n","Variante 1: Auswertung vom Item als String","\n","Die Struktur wird je Bit wie folgt aufgebaut: { Bitstatus0 \n , Bitstatus1 , .. , Bitstatus[i] }","\n","Der Bitstatus hat den String-Wert \"false\" \n oder \"true\"","\n","Diese 4 oder 5 String-Zeichen müssen je Bitstatus in \n einem GW-Skript ausgewertet werden und daraus ist ein numerischer Wert \n 0 bei false und 1 bei true zu bilden. Danach kann man die Werte weiterverarbeiten.","\n","Variante 2: Auswertung vom Item als Block","\n","Die Struktur wird je Bit wie folgt aufgebaut:","\n","7B <Nutzdaten Bit 0> 2C <Nutzdaten Bit 1> \n 2C .. <Nutzdaten Bit [i]> 7D","\n","2C hex ist das Trennzeichen Komma und 7B / 7D hex sind \n die beiden Klammern { und }.","\n","Der Bool'sche Wert wird übergeben als:","\n","HEX ASCII","\n","66 hex = f","\n","61 hex = a","\n","6C hex = l","\n","73 hex = s","\n","65 hex = e","\n","oder:","\n","HEX ASCII","\n","74 hex = t","\n","72 hex = r","\n","75 hex = u","\n","65 hex = e","\n","Auch hier müssen zuerst die beiden Klammern und die \n Kommas entfernt werden. Danach können die Bytes als ASCII-Zeichen gewandelt \n werden. Als Ergebnis erhält man wieder die Werte \"true\" oder \n \"false\", die in 1 oder 0 zu wandeln sind.","\n\n\n"]],"2":[["OPC_UA"]],"4":[["Neuen OPC_UA-Server anlegen"],["Funktionen"],["Serverstruktur"],["Namensräume"],["SPS Wert anlegen"],["Funktionalität in Skripten"],["Sonderfälle"]],"5":[["OPC_UA"]],"6":[["Begrenzung der Subscriptions"],["Auswertungen von Strukturen in der SPS"],["Auswertung von Bit-Arrays mit OPC-UA"]],"id":"23"})